import React, { useEffect, useState, useMemo } from "react";
import {
  MaterialReactTable,
  useMaterialReactTable,
} from "material-react-table";
import {
  MenuItem,
  TextField,
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Checkbox,
  CircularProgress,
  Snackbar,
  Alert,
} from "@mui/material";
import axios from "axios";

// Dropdown options
const ProfileTypeOptions = ["Provider", "Consumer", "Both", "Inheritor"];
const BusinessUnitOptions = ["ABC", "UIO", "POA", "SKA-C", "Other"];
const MaturityProjectionOptions = ["Increase", "Decrease", "Maintain"];

/* -------------------------------------------------------------------------- */
/*                         Helper: sanitizeInput                              */
/* -------------------------------------------------------------------------- */
const sanitizeInput = (str) => {
  // Remove angle brackets to mitigate XSS; React escapes by default.
  return str.replace(/[<>]/g, "");
};

/* -------------------------------------------------------------------------- */
/*            WorkerNamesModalEdit – Modal for Worker Search                  */
/* -------------------------------------------------------------------------- */
// This modal now shows two text fields (FirstName & LastName), and a Search button.
// The API is called only after clicking Search, and results are shown in a list with checkboxes.
// Multiple selections are allowed. If an API error occurs or no workers are found,
// a Snackbar toaster displays the error.
const WorkerNamesModalEdit = ({ cell, label, fetchWorkerNames }) => {
  const [open, setOpen] = useState(false);
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [loading, setLoading] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [selectedWorkers, setSelectedWorkers] = useState([]);
  const [snackbar, setSnackbar] = useState({ open: false, message: "", severity: "error" });

  const handleOpen = () => {
    setOpen(true);
    setFirstName("");
    setLastName("");
    setSearchResults([]);
    setSelectedWorkers([]);
  };

  const handleClose = () => {
    setOpen(false);
  };

  const handleSearch = async () => {
    const fName = sanitizeInput(firstName.trim());
    const lName = sanitizeInput(lastName.trim());
    if (!fName || !lName) {
      setSnackbar({ open: true, message: "Please enter both first and last names.", severity: "error" });
      return;
    }
    setLoading(true);
    try {
      const results = await fetchWorkerNames(fName, lName);
      if (results.length === 0) {
        setSnackbar({ open: true, message: "No workers found for that name.", severity: "error" });
      }
      setSearchResults(results);
    } catch (error) {
      setSnackbar({ open: true, message: "Error fetching workers.", severity: "error" });
      setSearchResults([]);
    } finally {
      setLoading(false);
    }
  };

  const handleToggle = (worker) => {
    const currentIndex = selectedWorkers.findIndex((w) => w.value === worker.value);
    let newSelected = [];
    if (currentIndex === -1) {
      newSelected = [...selectedWorkers, worker];
    } else {
      newSelected = selectedWorkers.filter((w) => w.value !== worker.value);
    }
    setSelectedWorkers(newSelected);
  };

  // Helper to update the cell value
  const updateCellValue = (newValue) => {
    // MRT v3 sometimes does not supply cell.setValue.
    if (cell && typeof cell.setValue === "function") {
      cell.setValue(newValue);
    } else if (cell?.column?.columnDef?.meta?.updateCellValue) {
      // Fallback: use the update function from meta if available.
      cell.column.columnDef.meta.updateCellValue(cell, newValue);
    } else {
      console.error("No update function available for cell.");
    }
  };

  const handleDone = () => {
    const names = selectedWorkers.map((w) => w.value).join(", ");
    updateCellValue(names);
    handleClose();
  };

  return (
    <>
      <Button variant="outlined" size="small" onClick={handleOpen}>
        Edit {label}
      </Button>
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>Edit {label}</DialogTitle>
        <DialogContent>
          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
            <TextField
              label="First Name"
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              fullWidth
            />
            <TextField
              label="Last Name"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              fullWidth
            />
          </Box>
          <Button variant="contained" onClick={handleSearch} disabled={loading}>
            {loading ? <CircularProgress size={24} /> : "Search"}
          </Button>
          {searchResults.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle1">Select Worker(s):</Typography>
              <List>
                {searchResults.map((worker) => {
                  const labelId = `checkbox-list-label-${worker.value}`;
                  return (
                    <ListItem
                      key={worker.value}
                      button
                      onClick={() => handleToggle(worker)}
                    >
                      <ListItemIcon>
                        <Checkbox
                          edge="start"
                          checked={selectedWorkers.findIndex((w) => w.value === worker.value) !== -1}
                          tabIndex={-1}
                          disableRipple
                          inputProps={{ "aria-labelledby": labelId }}
                        />
                      </ListItemIcon>
                      <ListItemText
                        id={labelId}
                        primary={worker.value}
                        secondary={`Job: ${worker.jobTitle} | Supervisor: ${worker.supervisorFullName}`}
                      />
                    </ListItem>
                  );
                })}
              </List>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Cancel</Button>
          <Button onClick={handleDone} variant="contained">
            Done
          </Button>
        </DialogActions>
      </Dialog>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() => setSnackbar((prev) => ({ ...prev, open: false }))}
      >
        <Alert
          onClose={() => setSnackbar((prev) => ({ ...prev, open: false }))}
          severity={snackbar.severity}
          sx={{ width: "100%" }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </>
  );
};

/* -------------------------------------------------------------------------- */
/*                   CSFScopeTable Component (Nested Tables)                */
/* -------------------------------------------------------------------------- */
const CSFScopeTable = () => {
  const [tableData, setTableData] = useState([]);

  // Fetch Scope Data and group by subcategoryId
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("/api/ScopeData");
        const groupedData = Object.values(
          response.data.reduce((acc, item) => {
            if (!acc[item.subcategoryId]) {
              acc[item.subcategoryId] = {
                subcategoryId: item.subcategoryId,
                subcategoryName: item.subcategoryName,
                subcategoryDescription: item.subcategoryDescription,
                relatedSubcategories: item.relatedCsf1_1Subcategories,
                businessUnits: [],
              };
            }
            acc[item.subcategoryId].businessUnits.push(item);
            return acc;
          }, {})
        );
        setTableData(groupedData);
      } catch (error) {
        console.error("Error fetching scope data:", error);
      }
    };
    fetchData();
  }, []);

  // API call to fetch Worker Names – uses sanitized first and last name.
  const fetchWorkerNames = async (firstName, lastName) => {
    try {
      const response = await axios.get(`/api/GetWorkerName`, {
        params: { FirstName: firstName, LastName: lastName },
      });
      return response.data.map((worker) => ({
        label: `${worker.NameFull} - ${worker.JobTitle} (Supervisor: ${worker.SupervisorFullName})`,
        value: worker.NameFull,
        jobTitle: worker.JobTitle,
        supervisorFullName: worker.SupervisorFullName,
      }));
    } catch (error) {
      console.error("Error fetching worker names:", error);
      return [];
    }
  };

  // LEVEL 1: Subcategory Columns (Display Only with Filtering)
  const subcategoryColumns = useMemo(
    () => [
      {
        accessorKey: "subcategoryName",
        header: "Subcategory",
        size: 120,
        filterVariant: "multi-select",
        filterSelectOptions: [
          ...new Set(tableData.map((row) => row.subcategoryName)),
        ],
      },
      {
        accessorKey: "subcategoryDescription",
        header: "Description",
        size: 300,
        filterVariant: "text",
        Cell: ({ cell }) => (
          <div
            style={{
              whiteSpace: "normal",
              wordWrap: "break-word",
              overflowWrap: "break-word",
            }}
          >
            {cell.getValue()}
          </div>
        ),
      },
      {
        accessorKey: "relatedSubcategories",
        header: "Related Subcategories",
        filterVariant: "text",
      },
    ],
    [tableData]
  );

  // LEVEL 2: Business Unit Columns (Fully Editable)
  const businessUnitColumns = useMemo(
    () => [
      {
        accessorKey: "businessUnitAbbr",
        header: "BU",
        enableEditing: false,
      },
      {
        accessorKey: "businessUnitOwner",
        header: "BU Owner",
        // Use our modal editor for multiple selection
        Edit: ({ cell }) => (
          <WorkerNamesModalEdit cell={cell} label="BU Owner" fetchWorkerNames={fetchWorkerNames} />
        ),
      },
      {
        accessorKey: "auditorSubcatCustodian",
        header: "Auditor Custodian",
        Edit: ({ cell }) => (
          <WorkerNamesModalEdit cell={cell} label="Auditor Custodian" fetchWorkerNames={fetchWorkerNames} />
        ),
      },
      {
        accessorKey: "auditorIsInScope",
        header: "In Scope?",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              if (newValue === "Yes") {
                cell.row.getCell("auditorJustification").setValue("");
              }
            }}
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </TextField>
        ),
      },
      {
        accessorKey: "auditorJustification",
        header: "Justification",
        Edit: ({ cell, row }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
            disabled={row.getValue("auditorIsInScope") !== "No"}
          />
        ),
      },
      {
        accessorKey: "maturityProjection",
        header: "Maturity Projection",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
          >
            {MaturityProjectionOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorProfileType",
        header: "Profile Type",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              if (!["Consumer", "Both"].includes(newValue)) {
                cell.row.getCell("auditorConsumingFromBusinessUnit").setValue("");
              }
            }}
          >
            {ProfileTypeOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorConsumingFromBusinessUnit",
        header: "Consuming From BU",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
            disabled={
              row.getValue("auditorProfileType") !== "Consumer" &&
              row.getValue("auditorProfileType") !== "Both"
            }
          >
            {BusinessUnitOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "departmentName",
        header: "Department Name",
        Edit: ({ cell }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
          />
        ),
      },
    ],
    [fetchWorkerNames]
  );

  return (
    <MaterialReactTable
      columns={subcategoryColumns}
      data={tableData}
      enableFilters
      enableEditing={false}
      renderDetailPanel={({ row }) => (
        <MaterialReactTable
          columns={businessUnitColumns}
          data={row.original.businessUnits}
          enableEditing
          editDisplayMode="row"
          muiTableContainerProps={{ sx: { overflowX: "auto" } }}
          // LEVEL 3: Render a detail panel under each BU row with profile type definitions
          renderDetailPanel={() => (
            <Box
              p={2}
              sx={{
                backgroundColor: "#f4f4f4",
                borderRadius: "8px",
                marginTop: "10px",
              }}
            >
              <Typography variant="h6">Profile Type Definitions</Typography>
              <ul>
                <li>
                  <strong>Provider:</strong> Supplies services to other BUs.
                </li>
                <li>
                  <strong>Consumer:</strong> Receives services from other BUs.
                </li>
                <li>
                  <strong>Both:</strong> Acts as both Provider & Consumer.
                </li>
                <li>
                  <strong>Inheritor:</strong> Inherits control from another BU.
                </li>
              </ul>
            </Box>
          )}
        />
      )}
    />
  );
};

export default CSFScopeTable;
