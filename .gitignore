import React, { useState, useEffect, useMemo, useCallback } from 'react';
import MaterialReactTable, { useMaterialReactTable } from 'material-react-table';
import axios from 'axios';
import {
  Box,
  Button,
  TextField,
  Autocomplete,
  Select,
  MenuItem,
  Typography,
  CircularProgress,
} from '@mui/material';

/* -------------------------------------------------------------------------- */
/*                           Profile Type Definitions                         */
/* -------------------------------------------------------------------------- */

const profileTypeDefinitions = {
  Provider: 'Definition for Provider: ...',
  Consumer: 'Definition for Consumer: ...',
  Both: 'Definition for Both: ...',
  Inheritor: 'Definition for Inheritor: ...',
};

/* -------------------------------------------------------------------------- */
/*                           Custom Hooks                                     */
/* -------------------------------------------------------------------------- */

// Custom hook for fetching and grouping BUScopeData
const useFetchBUScopeData = () => {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchBUScopeData = useCallback(async () => {
    setLoading(true);
    try {
      const response = await axios.get('/api/GetBUScopeData');
      // Group flat data by subcategoryName
      const groupedData = {};
      response.data.forEach((item) => {
        if (!groupedData[item.subcategoryName]) {
          groupedData[item.subcategoryName] = {
            subcategoryName: item.subcategoryName,
            subcategoryDescription: item.subcategoryDescription,
            relatedCsf1_1Subcategories: item.relatedCsf1_1Subcategories,
            businessUnits: [],
          };
        }
        groupedData[item.subcategoryName].businessUnits.push(item);
      });
      setData(Object.values(groupedData));
      setError(null);
    } catch (err) {
      console.error('Error fetching BUScopeData:', err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchBUScopeData();
  }, [fetchBUScopeData]);

  return { data, loading, error, refetch: fetchBUScopeData };
};

// Custom hook for fetching WorkerInfo
const useFetchWorkerInfo = () => {
  const [workerNames, setWorkerNames] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const fetchWorkerInfo = useCallback(async () => {
    setLoading(true);
    try {
      const response = await axios.get('/api/GetWorkerInfo');
      setWorkerNames(response.data);
      setError(null);
    } catch (err) {
      console.error('Error fetching WorkerInfo:', err);
      setError(err);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    fetchWorkerInfo();
  }, [fetchWorkerInfo]);

  return { workerNames, loading, error, refetch: fetchWorkerInfo };
};

/* -------------------------------------------------------------------------- */
/*                   BusinessUnitsTable Component (Level 2/3)                 */
/* -------------------------------------------------------------------------- */

const BusinessUnitsTable = ({
  businessUnits,
  subcatIndex,
  updateBusinessUnitCell,
  workerNames,
  onAddBusinessUnit,
}) => {
  // Level 2: Define columns for Business Units
  const buColumns = useMemo(
    () => [
      {
        accessorKey: 'businessUnitAbbr',
        header: 'Business Unit',
        enableEditing: false,
      },
      {
        accessorKey: 'businessUnitOwner',
        header: 'BU Owner',
        Cell: ({ cell, row }) => (
          <Autocomplete
            options={workerNames.map((w) => w.NameFull)}
            value={cell.getValue() || ''}
            onChange={(event, newValue) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, newValue);
            }}
            renderInput={(params) => <TextField {...params} variant="standard" />}
          />
        ),
      },
      {
        accessorKey: 'auditorSubcatCustodian',
        header: 'Auditor Custodian',
        Cell: ({ cell, row }) => (
          <Autocomplete
            options={workerNames.map((w) => w.NameFull)}
            value={cell.getValue() || ''}
            onChange={(event, newValue) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, newValue);
            }}
            renderInput={(params) => <TextField {...params} variant="standard" />}
          />
        ),
      },
      {
        accessorKey: 'auditorIsInScope',
        header: 'In Scope',
        Cell: ({ cell, row }) => (
          <Select
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </Select>
        ),
      },
      {
        accessorKey: 'auditorJustification',
        header: 'Justification',
        Cell: ({ cell, row }) => (
          <TextField
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
            disabled={row.original.auditorIsInScope === 'Yes'} // Only editable if "No"
          />
        ),
      },
      {
        accessorKey: 'maturityProjection',
        header: 'Maturity Projection',
        Cell: ({ cell, row }) => (
          <Select
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
          >
            <MenuItem value="Increase">Increase</MenuItem>
            <MenuItem value="Decrease">Decrease</MenuItem>
            <MenuItem value="Maintain">Maintain</MenuItem>
          </Select>
        ),
      },
      {
        accessorKey: 'auditorProfileType',
        header: 'Profile Type',
        Cell: ({ cell, row }) => (
          <Select
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
            disabled={row.original.auditorIsInScope !== 'Yes'} // Enabled only when In Scope is "Yes"
          >
            <MenuItem value="Provider">Provider</MenuItem>
            <MenuItem value="Consumer">Consumer</MenuItem>
            <MenuItem value="Both">Both</MenuItem>
            <MenuItem value="Inheritor">Inheritor</MenuItem>
          </Select>
        ),
      },
      {
        accessorKey: 'auditorConsumingFromBusinessUnit',
        header: 'Consuming From BU',
        Cell: ({ cell, row }) => (
          <Select
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
            disabled={
              row.original.auditorProfileType !== 'Consumer' &&
              row.original.auditorProfileType !== 'Both'
            }
          >
            <MenuItem value="ABC">ABC</MenuItem>
            <MenuItem value="UIO">UIO</MenuItem>
            <MenuItem value="POA">POA</MenuItem>
            <MenuItem value="SKA-C">SKA-C</MenuItem>
            <MenuItem value="Other">Other</MenuItem>
          </Select>
        ),
      },
      {
        accessorKey: 'departmentName',
        header: 'Department Name',
        Cell: ({ cell, row }) => (
          <TextField
            value={cell.getValue() || ''}
            onChange={(event) => {
              cell.table.options.meta?.updateData(row.index, cell.column.id, event.target.value);
            }}
            variant="standard"
          />
        ),
      },
    ],
    [workerNames]
  );

  // Use the MRT hook to create a nested table instance
  const table = useMaterialReactTable({
    columns: buColumns,
    data: businessUnits,
    // Level 3: Render a detail panel for each Business Unit row
    renderDetailPanel: ({ row }) => (
      <Box sx={{ padding: 2 }}>
        <Typography variant="h6">Profile Type Definitions</Typography>
        <Typography variant="body2">
          {row.original.auditorProfileType
            ? profileTypeDefinitions[row.original.auditorProfileType]
            : 'No Profile Type selected.'}
        </Typography>
      </Box>
    ),
    meta: {
      updateData: (rowIndex, columnId, value) =>
        updateBusinessUnitCell(subcatIndex, rowIndex, columnId, value),
    },
    muiTableBodyCellEditTextFieldProps: { variant: 'standard' },
  });

  return (
    <Box sx={{ padding: 2 }}>
      <MaterialReactTable table={table} />
      <Button onClick={onAddBusinessUnit} sx={{ marginTop: 2 }}>
        Add Business Unit
      </Button>
    </Box>
  );
};

/* -------------------------------------------------------------------------- */
/*                  CSFScopeTable Component (Level 1)                         */
/* -------------------------------------------------------------------------- */

const CSFScopeTable = () => {
  // Use our custom hooks for API data
  const { data, loading: buscopeLoading, error: buscopeError } = useFetchBUScopeData();
  const { workerNames, loading: workerLoading, error: workerError } = useFetchWorkerInfo();

  // Mirror the fetched BUScopeData into state for editing
  const [tableData, setTableData] = useState([]);
  useEffect(() => {
    setTableData(data);
  }, [data]);

  // Update function for nested Business Unit cell updates
  const updateBusinessUnitCell = useCallback((subcatIndex, rowIndex, columnId, value) => {
    setTableData((prevData) => {
      const newData = [...prevData];
      newData[subcatIndex].businessUnits[rowIndex] = {
        ...newData[subcatIndex].businessUnits[rowIndex],
        [columnId]: value,
      };
      return newData;
    });
  }, []);

  // Function to add a new Business Unit row
  const onAddBusinessUnit = useCallback((subcatIndex) => {
    setTableData((prevData) => {
      const newData = [...prevData];
      const newRow = {
        businessUnitAbbr: '', // Display only
        businessUnitOwner: '',
        auditorSubcatCustodian: '',
        auditorIsInScope: '',
        auditorJustification: '',
        maturityProjection: '',
        auditorProfileType: '',
        auditorConsumingFromBusinessUnit: '',
        departmentName: '',
      };
      newData[subcatIndex].businessUnits = [
        ...newData[subcatIndex].businessUnits,
        newRow,
      ];
      return newData;
    });
  }, []);

  // Level 1: Main table columns for subcategory data
  const mainColumns = useMemo(
    () => [
      {
        accessorKey: 'subcategoryName',
        header: 'Subcategory Name',
        enableColumnFilter: true,
        filterVariant: 'multi-select',
      },
      {
        accessorKey: 'subcategoryDescription',
        header: 'Description',
      },
      {
        accessorKey: 'relatedCsf1_1Subcategories',
        header: 'Related Subcategories',
      },
    ],
    []
  );

  // Create main table instance using useMaterialReactTable
  const mainTable = useMaterialReactTable({
    columns: mainColumns,
    data: tableData,
    // Render Level 2 (nested table) in the row sub-component
    renderRowSubComponent: ({ row }) => (
      <BusinessUnitsTable
        businessUnits={row.original.businessUnits}
        subcatIndex={row.index}
        updateBusinessUnitCell={updateBusinessUnitCell}
        workerNames={workerNames}
        onAddBusinessUnit={() => onAddBusinessUnit(row.index)}
      />
    ),
  });

  if (buscopeLoading || workerLoading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', marginTop: 4 }}>
        <CircularProgress />
      </Box>
    );
  }

  if (buscopeError || workerError) {
    return (
      <Box sx={{ padding: 2 }}>
        <Typography color="error">Error loading data</Typography>
      </Box>
    );
  }

  return (
    <Box sx={{ padding: 2 }}>
      <MaterialReactTable table={mainTable} />
    </Box>
  );
};

export default CSFScopeTable;
