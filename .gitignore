import React, { useEffect, useState, useMemo } from "react";
import {
  MaterialReactTable,
  useMaterialReactTable,
} from "material-react-table";
import {
  MenuItem,
  TextField,
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  List,
  ListItem,
  ListItemIcon,
  ListItemText,
  Checkbox,
  CircularProgress,
  Snackbar,
  Alert,
} from "@mui/material";
import axios from "axios";

// Dropdown options
const ProfileTypeOptions = ["Provider", "Consumer", "Both", "Inheritor"];
const BusinessUnitOptions = ["ABC", "UIO", "POA", "SKA-C", "Other"];
const MaturityProjectionOptions = ["Increase", "Decrease", "Maintain"];

/* -------------------------------------------------------------------------- */
/*                          Helper: sanitizeInput                             */
/* -------------------------------------------------------------------------- */
const sanitizeInput = (str) => str.replace(/[<>]/g, "");

/* -------------------------------------------------------------------------- */
/*                WorkerNamesModalEdit – Modal for Worker Search              */
/* -------------------------------------------------------------------------- */
// This modal shows two text fields (FirstName & LastName) plus a Search button.
// The API is only called when Search is clicked. Search results (with extra details)
// are displayed as a list with checkboxes. Multiple selections are allowed.
// When Done is clicked, the provided updateCell function is called.
const WorkerNamesModalEdit = ({ cell, label, fetchWorkerNames, updateCell }) => {
  const [open, setOpen] = useState(false);
  const [firstName, setFirstName] = useState("");
  const [lastName, setLastName] = useState("");
  const [loading, setLoading] = useState(false);
  const [searchResults, setSearchResults] = useState([]);
  const [selectedWorkers, setSelectedWorkers] = useState([]);
  const [snackbar, setSnackbar] = useState({
    open: false,
    message: "",
    severity: "error",
  });

  const handleOpen = () => {
    setOpen(true);
    setFirstName("");
    setLastName("");
    setSearchResults([]);
    setSelectedWorkers([]);
  };

  const handleClose = () => {
    setOpen(false);
  };

  const handleSearch = async () => {
    const fName = sanitizeInput(firstName.trim());
    const lName = sanitizeInput(lastName.trim());
    if (!fName || !lName) {
      setSnackbar({
        open: true,
        message: "Please enter both first and last names.",
        severity: "error",
      });
      return;
    }
    setLoading(true);
    try {
      const results = await fetchWorkerNames(fName, lName);
      if (results.length === 0) {
        setSnackbar({
          open: true,
          message: "No workers found for that name.",
          severity: "error",
        });
      }
      setSearchResults(results);
    } catch (error) {
      setSnackbar({
        open: true,
        message: "Error fetching workers.",
        severity: "error",
      });
      setSearchResults([]);
    } finally {
      setLoading(false);
    }
  };

  const handleToggle = (worker) => {
    const currentIndex = selectedWorkers.findIndex(
      (w) => w.value === worker.value
    );
    let newSelected = [];
    if (currentIndex === -1) {
      newSelected = [...selectedWorkers, worker];
    } else {
      newSelected = selectedWorkers.filter((w) => w.value !== worker.value);
    }
    setSelectedWorkers(newSelected);
  };

  const handleDone = () => {
    const names = selectedWorkers.map((w) => w.value).join(", ");
    if (typeof updateCell === "function") {
      updateCell(names);
    } else if (cell && typeof cell.setValue === "function") {
      cell.setValue(names);
    } else {
      console.error("No update function available for cell.");
    }
    handleClose();
  };

  return (
    <>
      <Button variant="outlined" size="small" onClick={handleOpen}>
        Edit {label}
      </Button>
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>Edit {label}</DialogTitle>
        <DialogContent>
          <Box sx={{ display: "flex", gap: 2, mb: 2 }}>
            <TextField
              label="First Name"
              value={firstName}
              onChange={(e) => setFirstName(e.target.value)}
              fullWidth
            />
            <TextField
              label="Last Name"
              value={lastName}
              onChange={(e) => setLastName(e.target.value)}
              fullWidth
            />
          </Box>
          <Button
            variant="contained"
            onClick={handleSearch}
            disabled={loading}
          >
            {loading ? <CircularProgress size={24} /> : "Search"}
          </Button>
          {searchResults.length > 0 && (
            <Box sx={{ mt: 2 }}>
              <Typography variant="subtitle1">Select Worker(s):</Typography>
              <List>
                {searchResults.map((worker) => {
                  const labelId = `checkbox-list-label-${worker.value}`;
                  return (
                    <ListItem
                      key={worker.value}
                      button
                      onClick={() => handleToggle(worker)}
                    >
                      <ListItemIcon>
                        <Checkbox
                          edge="start"
                          checked={
                            selectedWorkers.findIndex(
                              (w) => w.value === worker.value
                            ) !== -1
                          }
                          tabIndex={-1}
                          disableRipple
                          inputProps={{ "aria-labelledby": labelId }}
                        />
                      </ListItemIcon>
                      <ListItemText
                        id={labelId}
                        primary={worker.value}
                        secondary={`Job: ${worker.jobTitle} | Supervisor: ${worker.supervisorFullName}`}
                      />
                    </ListItem>
                  );
                })}
              </List>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Cancel</Button>
          <Button onClick={handleDone} variant="contained">
            Done
          </Button>
        </DialogActions>
      </Dialog>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() =>
          setSnackbar((prev) => ({ ...prev, open: false }))
        }
      >
        <Alert
          onClose={() =>
            setSnackbar((prev) => ({ ...prev, open: false }))
          }
          severity={snackbar.severity}
          sx={{ width: "100%" }}
        >
          {snackbar.message}
        </Alert>
      </Snackbar>
    </>
  );
};

/* -------------------------------------------------------------------------- */
/*                NestedBUScopeTable Component (Level 2 & 3)                  */
/* -------------------------------------------------------------------------- */
const NestedBUScopeTable = ({
  businessUnits,
  subcatIndex,
  updateBusinessUnitCell,
  fetchWorkerNames,
}) => {
  const businessUnitColumns = useMemo(
    () => [
      {
        accessorKey: "businessUnitAbbr",
        header: "BU",
        enableEditing: false,
      },
      {
        accessorKey: "businessUnitOwner",
        header: "BU Owner",
        Edit: ({ cell, row }) => (
          <WorkerNamesModalEdit
            cell={cell}
            label="BU Owner"
            fetchWorkerNames={fetchWorkerNames}
            updateCell={(newValue) =>
              updateBusinessUnitCell(subcatIndex, row.index, cell.column.id, newValue)
            }
          />
        ),
      },
      {
        accessorKey: "auditorSubcatCustodian",
        header: "Auditor Custodian",
        Edit: ({ cell, row }) => (
          <WorkerNamesModalEdit
            cell={cell}
            label="Auditor Custodian"
            fetchWorkerNames={fetchWorkerNames}
            updateCell={(newValue) =>
              updateBusinessUnitCell(subcatIndex, row.index, cell.column.id, newValue)
            }
          />
        ),
      },
      {
        accessorKey: "auditorIsInScope",
        header: "In Scope?",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              if (newValue === "Yes") {
                cell.row.getCell("auditorJustification").setValue("");
              }
            }}
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </TextField>
        ),
      },
      {
        accessorKey: "auditorJustification",
        header: "Justification",
        Edit: ({ cell, row }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) =>
              cell.setValue(event.target.value)
            }
            disabled={row.getValue("auditorIsInScope") !== "No"}
          />
        ),
      },
      {
        accessorKey: "maturityProjection",
        header: "Maturity Projection",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) =>
              cell.setValue(event.target.value)
            }
          >
            {MaturityProjectionOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorProfileType",
        header: "Profile Type",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              if (!["Consumer", "Both"].includes(newValue)) {
                cell.row.getCell("auditorConsumingFromBusinessUnit").setValue("");
              }
            }}
          >
            {ProfileTypeOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorConsumingFromBusinessUnit",
        header: "Consuming From BU",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
            disabled={
              row.getValue("auditorProfileType") !== "Consumer" &&
              row.getValue("auditorProfileType") !== "Both"
            }
          >
            {BusinessUnitOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "departmentName",
        header: "Department Name",
        Edit: ({ cell }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
          />
        ),
      },
    ],
    [updateBusinessUnitCell, subcatIndex, fetchWorkerNames]
  );

  const nestedTable = useMaterialReactTable({
    columns: businessUnitColumns,
    data: businessUnits,
    enableEditing: true,
    editDisplayMode: "row",
    muiTableBodyCellEditTextFieldProps: { variant: "standard" },
    meta: {
      updateData: (rowIndex, columnId, value) =>
        updateBusinessUnitCell(subcatIndex, rowIndex, columnId, value),
    },
    renderDetailPanel: ({ row }) => (
      <Box
        p={2}
        sx={{
          backgroundColor: "#f4f4f4",
          borderRadius: "8px",
          marginTop: "10px",
        }}
      >
        <Typography variant="h6">Profile Type Definitions</Typography>
        <ul>
          <li>
            <strong>Provider:</strong> Supplies services to other BUs.
          </li>
          <li>
            <strong>Consumer:</strong> Receives services from other BUs.
          </li>
          <li>
            <strong>Both:</strong> Acts as both Provider & Consumer.
          </li>
          <li>
            <strong>Inheritor:</strong> Inherits control from another BU.
          </li>
        </ul>
      </Box>
    ),
  });

  return (
    <Box>
      <MaterialReactTable table={nestedTable} />
    </Box>
  );
};

/* -------------------------------------------------------------------------- */
/*                  CSFScopeTable Component (Level 1)                         */
/* -------------------------------------------------------------------------- */
const CSFScopeTable = () => {
  const [tableData, setTableData] = useState([]);

  // Fetch Scope Data and group by subcategoryId
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("/api/ScopeData");
        const groupedData = Object.values(
          response.data.reduce((acc, item) => {
            if (!acc[item.subcategoryId]) {
              acc[item.subcategoryId] = {
                subcategoryId: item.subcategoryId,
                subcategoryName: item.subcategoryName,
                subcategoryDescription: item.subcategoryDescription,
                relatedSubcategories: item.relatedCsf1_1Subcategories,
                businessUnits: [],
              };
            }
            acc[item.subcategoryId].businessUnits.push(item);
            return acc;
          }, {})
        );
        setTableData(groupedData);
      } catch (error) {
        console.error("Error fetching scope data:", error);
      }
    };
    fetchData();
  }, []);

  // API call to fetch Worker Names – uses sanitized first and last name.
  const fetchWorkerNames = async (firstName, lastName) => {
    try {
      const response = await axios.get(`/api/GetWorkerName`, {
        params: { FirstName: firstName, LastName: lastName },
      });
      return response.data.map((worker) => ({
        label: `${worker.NameFull} - ${worker.JobTitle} (Supervisor: ${worker.SupervisorFullName})`,
        value: worker.NameFull,
        jobTitle: worker.JobTitle,
        supervisorFullName: worker.SupervisorFullName,
      }));
    } catch (error) {
      console.error("Error fetching worker names:", error);
      return [];
    }
  };

  // LEVEL 1: Subcategory Columns (Display Only with Filtering)
  const subcategoryColumns = useMemo(
    () => [
      {
        accessorKey: "subcategoryName",
        header: "Subcategory",
        size: 120,
        filterVariant: "multi-select",
        filterSelectOptions: [
          ...new Set(tableData.map((row) => row.subcategoryName)),
        ],
      },
      {
        accessorKey: "subcategoryDescription",
        header: "Description",
        size: 300,
        filterVariant: "text",
        Cell: ({ cell }) => (
          <div
            style={{
              whiteSpace: "normal",
              wordWrap: "break-word",
              overflowWrap: "break-word",
            }}
          >
            {cell.getValue()}
          </div>
        ),
      },
      {
        accessorKey: "relatedSubcategories",
        header: "Related Subcategories",
        filterVariant: "text",
      },
    ],
    [tableData]
  );

  // Create main table instance using MRT hook (Level 1)
  const mainTable = useMaterialReactTable({
    columns: subcategoryColumns,
    data: tableData,
    enableRowExpansion: true,
    renderRowSubComponent: ({ row }) => (
      <NestedBUScopeTable
        businessUnits={row.original.businessUnits}
        subcatIndex={row.index}
        updateBusinessUnitCell={(subcatIdx, rowIdx, columnId, value) => {
          setTableData((prev) => {
            const newData = [...prev];
            newData[subcatIdx].businessUnits[rowIdx] = {
              ...newData[subcatIdx].businessUnits[rowIdx],
              [columnId]: value,
            };
            return newData;
          });
        }}
        fetchWorkerNames={fetchWorkerNames}
      />
    ),
  });

  return (
    <Box sx={{ p: 2 }}>
      <MaterialReactTable table={mainTable} />
    </Box>
  );
};

export default CSFScopeTable;
