import React, { useEffect, useState, useMemo } from 'react';
import MaterialReactTable from 'material-react-table';
import { MenuItem, TextField, Autocomplete, Box, Typography } from '@mui/material';
import axios from 'axios';

// Options for Dropdowns
const ProfileTypeOptions = ['Provider', 'Consumer', 'Both', 'Inheritor'];
const BusinessUnitOptions = ['ABC', 'UIO', 'POA', 'SKA-C'];

// Fetch worker names dynamically from API
const fetchWorkerNames = async (inputValue) => {
  try {
    const response = await axios.get(`/api/GetWorkerName?search=${inputValue}`);
    return response.data || [];
  } catch (error) {
    console.error('Error fetching worker names:', error);
    return [];
  }
};

const CSFScopeTable = () => {
  const [tableData, setTableData] = useState([]);

  // Fetch Data on Component Mount
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get('/api/ScopeData');
        // Group data by subcategory
        const groupedData = Object.values(
          response.data.reduce((acc, item) => {
            if (!acc[item.subcategoryId]) {
              acc[item.subcategoryId] = {
                subcategoryId: item.subcategoryId,
                subcategoryName: item.subcategoryName,
                subcategoryDescription: item.subcategoryDescription,
                relatedSubcategories: item.relatedCsf1_1Subcategories,
                businessUnits: [],
              };
            }
            acc[item.subcategoryId].businessUnits.push(item);
            return acc;
          }, {})
        );
        setTableData(groupedData);
      } catch (error) {
        console.error('Error fetching scope data:', error);
      }
    };
    fetchData();
  }, []);

  // Handle Cell Edit
  const handleCellEdit = (cell, value) => {
    const updatedData = [...tableData];
    const subcategory = updatedData.find(
      (sub) => sub.subcategoryId === cell.row.original.subcategoryId
    );
    if (subcategory) {
      const buIndex = subcategory.businessUnits.findIndex(
        (bu) => bu.businessUnitAbbr === cell.row.original.businessUnitAbbr
      );
      if (buIndex !== -1) {
        subcategory.businessUnits[buIndex][cell.column.id] = value;
      }
    }
    setTableData(updatedData);
  };

  // **Layer 1: Subcategory Level Columns**
  const SubcategoryColumns = useMemo(
    () => [
      {
        accessorKey: 'subcategoryName',
        header: 'Subcategory Name',
      },
      {
        accessorKey: 'subcategoryDescription',
        header: 'Subcategory Description',
      },
      {
        accessorKey: 'relatedSubcategories',
        header: 'Related Subcategories',
        Cell: ({ cell }) => cell.getValue() || 'N/A',
      },
    ],
    []
  );

  // **Layer 2: Business Unit Level (Editable Fields)**
  const BusinessUnitColumns = useMemo(
    () => [
      {
        accessorKey: 'businessUnitAbbr',
        header: 'Business Unit',
        enableEditing: false, // Make it read-only
      },
      {
        accessorKey: 'businessUnitOwner',
        header: 'Business Unit Owner',
        Cell: ({ cell }) => (cell.getValue() ? cell.getValue().split(', ').join(', ') : 'N/A'),
        Edit: ({ cell }) => (
          <Autocomplete
            multiple
            options={[]} // Will be updated dynamically
            defaultValue={cell.getValue() ? cell.getValue().split(', ') : []}
            onInputChange={async (event, newValue) => {
              if (newValue) {
                const workerNames = await fetchWorkerNames(newValue);
                handleCellEdit(cell, workerNames.join(', '));
              }
            }}
            renderInput={(params) => <TextField {...params} label="Search Owners" />}
          />
        ),
      },
      {
        accessorKey: 'auditorSubcatCustodian',
        header: 'Auditor Subcategory Custodian',
        Cell: ({ cell }) => (cell.getValue() ? cell.getValue().split(', ').join(', ') : 'N/A'),
        Edit: ({ cell }) => (
          <Autocomplete
            multiple
            options={[]} // Will be updated dynamically
            defaultValue={cell.getValue() ? cell.getValue().split(', ') : []}
            onInputChange={async (event, newValue) => {
              if (newValue) {
                const workerNames = await fetchWorkerNames(newValue);
                handleCellEdit(cell, workerNames.join(', '));
              }
            }}
            renderInput={(params) => <TextField {...params} label="Search Custodians" />}
          />
        ),
      },
      {
        accessorKey: 'auditorIsInScope',
        header: 'Auditor Is In Scope',
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ''}
            onChange={(event) => handleCellEdit(cell, event.target.value)}
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </TextField>
        ),
      },
      {
        accessorKey: 'auditorJustification',
        header: 'Auditor Justification',
        Edit: ({ cell }) => (
          <TextField
            defaultValue={cell.getValue()
::contentReference[oaicite:16]{index=16}
 
