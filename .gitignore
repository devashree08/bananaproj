import React, { useEffect, useState, useMemo } from "react";
import {
  MaterialReactTable,
  useMaterialReactTable,
} from "material-react-table";
import {
  MenuItem,
  TextField,
  Autocomplete,
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  CircularProgress,
} from "@mui/material";
import axios from "axios";

// Options for dropdowns
const ProfileTypeOptions = ["Provider", "Consumer", "Both", "Inheritor"];
const BusinessUnitOptions = ["ABC", "UIO", "POA", "SKA-C", "Other"];
const MaturityProjectionOptions = ["Increase", "Decrease", "Maintain"];

/* -------------------------------------------------------------------------- */
/*                WorkerNamesModalEdit (Modal Editor)                       */
/* -------------------------------------------------------------------------- */
// This modal is used for BU Owner and Auditor Custodian edits.
// It calls the WorkerInfo API (passing FirstName & LastName) to search among 200K+ records.
// It displays additional details (Job Title, Supervisor) in the option list.
// It supports multiple selections.
const WorkerNamesModalEdit = ({ cell, label, fetchWorkerNames }) => {
  const [open, setOpen] = useState(false);
  const [inputValue, setInputValue] = useState("");
  const [options, setOptions] = useState([]);

  // Convert current cell value (a comma-separated string) into an array of worker objects.
  const currentValue =
    cell.getValue() && cell.getValue().length > 0
      ? cell.getValue().split(", ").map((name) => ({
          value: name,
          label: name,
          jobTitle: "",
          supervisorFullName: "",
        }))
      : [];

  const handleOpen = () => {
    setOpen(true);
    setInputValue("");
    setOptions([]);
  };

  const handleClose = () => {
    setOpen(false);
  };

  // When the input changes, call the API if it contains a space (assumed "First Last")
  const handleInputChange = async (event, newValue) => {
    setInputValue(newValue);
    if (newValue.includes(" ")) {
      const results = await fetchWorkerNames(newValue);
      setOptions(results);
    } else {
      setOptions([]);
    }
  };

  // When selection changes, update the cell value (storing as a comma-separated string)
  const handleSelectChange = (event, newSelected) => {
    const names = newSelected.map((worker) => worker.value);
    cell.setValue(names.join(", "));
  };

  return (
    <>
      <Button variant="outlined" size="small" onClick={handleOpen}>
        Edit {label}
      </Button>
      <Dialog open={open} onClose={handleClose} fullWidth maxWidth="sm">
        <DialogTitle>Edit {label}</DialogTitle>
        <DialogContent>
          <Autocomplete
            multiple
            options={options}
            getOptionLabel={(option) =>
              `${option.value} - ${option.jobTitle} (Supervisor: ${option.supervisorFullName})`
            }
            value={currentValue}
            onChange={handleSelectChange}
            onInputChange={handleInputChange}
            filterSelectedOptions
            renderInput={(params) => (
              <TextField
                {...params}
                label={`${label} (Enter "First Last")`}
                placeholder="Search..."
              />
            )}
          />
        </DialogContent>
        <DialogActions>
          <Button onClick={handleClose}>Done</Button>
        </DialogActions>
      </Dialog>
    </>
  );
};

/* -------------------------------------------------------------------------- */
/*                    CSFScopeTable Component (Nested Table)                */
/* -------------------------------------------------------------------------- */
const CSFScopeTable = () => {
  const [tableData, setTableData] = useState([]);

  // Fetch Scope Data and group by subcategoryId
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("/api/ScopeData");
        const groupedData = Object.values(
          response.data.reduce((acc, item) => {
            if (!acc[item.subcategoryId]) {
              acc[item.subcategoryId] = {
                subcategoryId: item.subcategoryId,
                subcategoryName: item.subcategoryName,
                subcategoryDescription: item.subcategoryDescription,
                relatedSubcategories: item.relatedCsf1_1Subcategories,
                businessUnits: [],
              };
            }
            acc[item.subcategoryId].businessUnits.push(item);
            return acc;
          }, {})
        );
        setTableData(groupedData);
      } catch (error) {
        console.error("Error fetching scope data:", error);
      }
    };
    fetchData();
  }, []);

  // API call to fetch Worker Names â€“ passing FirstName and LastName as parameters.
  const fetchWorkerNames = async (inputValue) => {
    if (!inputValue.includes(" ")) return [];
    const [firstName, lastName] = inputValue.split(" ");
    try {
      const response = await axios.get(`/api/GetWorkerName`, {
        params: { FirstName: firstName, LastName: lastName },
      });
      return response.data.map((worker) => ({
        label: `${worker.NameFull} - ${worker.JobTitle} (Supervisor: ${worker.SupervisorFullName})`,
        value: worker.NameFull,
        jobTitle: worker.JobTitle,
        supervisorFullName: worker.SupervisorFullName,
      }));
    } catch (error) {
      console.error("Error fetching worker names:", error);
      return [];
    }
  };

  // LEVEL 1: Subcategory Level (Display Only)
  const subcategoryColumns = useMemo(
    () => [
      {
        accessorKey: "subcategoryName",
        header: "Subcategory",
        size: 120,
        filterVariant: "multi-select",
        filterSelectOptions: [
          ...new Set(tableData.map((row) => row.subcategoryName)),
        ],
      },
      {
        accessorKey: "subcategoryDescription",
        header: "Description",
        size: 300,
        filterVariant: "text",
        Cell: ({ cell }) => (
          <div
            style={{
              whiteSpace: "normal",
              wordWrap: "break-word",
              overflowWrap: "break-word",
            }}
          >
            {cell.getValue()}
          </div>
        ),
      },
      {
        accessorKey: "relatedSubcategories",
        header: "Related Subcategories",
        filterVariant: "text",
      },
    ],
    [tableData]
  );

  // LEVEL 2: Business Unit Level (Fully Editable)
  const businessUnitColumns = useMemo(
    () => [
      {
        accessorKey: "businessUnitAbbr",
        header: "BU",
        enableEditing: false,
      },
      {
        accessorKey: "businessUnitOwner",
        header: "BU Owner",
        // Use the modal for multiple selection editing
        Edit: ({ cell }) => (
          <WorkerNamesModalEdit
            cell={cell}
            label="BU Owner"
            fetchWorkerNames={fetchWorkerNames}
          />
        ),
      },
      {
        accessorKey: "auditorSubcatCustodian",
        header: "Auditor Custodian",
        Edit: ({ cell }) => (
          <WorkerNamesModalEdit
            cell={cell}
            label="Auditor Custodian"
            fetchWorkerNames={fetchWorkerNames}
          />
        ),
      },
      {
        accessorKey: "auditorIsInScope",
        header: "In Scope?",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              // If "Yes", clear justification.
              if (newValue === "Yes") {
                cell.row.getCell("auditorJustification").setValue("");
              }
            }}
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </TextField>
        ),
      },
      {
        accessorKey: "auditorJustification",
        header: "Justification",
        Edit: ({ cell, row }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
            disabled={row.getValue("auditorIsInScope") !== "No"}
          />
        ),
      },
      {
        accessorKey: "maturityProjection",
        header: "Maturity Projection",
        Edit: ({ cell }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
          >
            {MaturityProjectionOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorProfileType",
        header: "Profile Type",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => {
              const newValue = event.target.value;
              cell.setValue(newValue);
              if (!["Consumer", "Both"].includes(newValue)) {
                cell.row.getCell("auditorConsumingFromBusinessUnit").setValue("");
              }
            }}
          >
            {ProfileTypeOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "auditorConsumingFromBusinessUnit",
        header: "Consuming From BU",
        Edit: ({ cell, row }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
            disabled={
              row.getValue("auditorProfileType") !== "Consumer" &&
              row.getValue("auditorProfileType") !== "Both"
            }
          >
            {BusinessUnitOptions.map((option) => (
              <MenuItem key={option} value={option}>
                {option}
              </MenuItem>
            ))}
          </TextField>
        ),
      },
      {
        accessorKey: "departmentName",
        header: "Department Name",
        Edit: ({ cell }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => cell.setValue(event.target.value)}
          />
        ),
      },
    ],
    [fetchWorkerNames]
  );

  return (
    <MaterialReactTable
      columns={subcategoryColumns}
      data={tableData}
      enableFilters
      enableEditing={false}
      renderDetailPanel={({ row }) => (
        <MaterialReactTable
          columns={businessUnitColumns}
          data={row.original.businessUnits}
          enableEditing
          editDisplayMode="row"
          muiTableContainerProps={{ sx: { overflowX: "auto" } }}
          // LEVEL 3: Render a detail panel under each BU row with profile type definitions
          renderDetailPanel={() => (
            <Box
              p={2}
              sx={{
                backgroundColor: "#f4f4f4",
                borderRadius: "8px",
                marginTop: "10px",
              }}
            >
              <Typography variant="h6">Profile Type Definitions</Typography>
              <ul>
                <li>
                  <strong>Provider:</strong> Supplies services to other BUs.
                </li>
                <li>
                  <strong>Consumer:</strong> Receives services from other BUs.
                </li>
                <li>
                  <strong>Both:</strong> Acts as both Provider &amp; Consumer.
                </li>
                <li>
                  <strong>Inheritor:</strong> Inherits control from another BU.
                </li>
              </ul>
            </Box>
          )}
        />
      )}
    />
  );
};

export default CSFScopeTable;
