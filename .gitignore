// CSFScopeAGGrid.jsx
import React, { useState, useEffect, useMemo, forwardRef, useImperativeHandle } from 'react';
import { AgGridReact } from 'ag-grid-react';
import { ModuleRegistry, AllCommunityModule } from 'ag-grid-community';
import axios from 'axios';
import { Box, Button, Dialog, DialogTitle, DialogContent, DialogActions, TextField, List, ListItem, ListItemIcon, ListItemText, Checkbox, CircularProgress, Snackbar, Alert } from '@mui/material';
import 'ag-grid-community/dist/styles/ag-grid.css';
import 'ag-grid-community/dist/styles/ag-theme-alpine.css';

// Register the community module per current v33 docs.
ModuleRegistry.registerModules([AllCommunityModule]);

// ----------------------- WorkerNamesCellEditor -----------------------
// A custom cell editor that opens a modal to search for worker names.
// It uses two text fields (First Name and Last Name) and a Search button to call the WorkerInfo API.
// The user can select multiple names; when Done is clicked, the editor returns a comma-separated string.
const WorkerNamesCellEditor = forwardRef((props, ref) => {
  // Props from AG Grid include: value (current cell value), colDef, stopEditing(), etc.
  const [open, setOpen] = useState(true);
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState([]);
  const [selected, setSelected] = useState([]);
  const [snackbar, setSnackbar] = useState({ open: false, message: '', severity: 'error' });

  // Expose getValue() so AG Grid can commit the new value when editing stops.
  useImperativeHandle(ref, () => ({
    getValue() {
      return selected.join(', ');
    }
  }));

  // Simple input sanitization
  const sanitizeInput = (str) => str.replace(/[<>]/g, '');

  const searchWorkers = async () => {
    if (!firstName.trim() || !lastName.trim()) {
      setSnackbar({ open: true, message: 'Please enter both first and last names', severity: 'error' });
      return;
    }
    setLoading(true);
    try {
      const response = await axios.get('/api/GetWorkerName', {
        params: { FirstName: sanitizeInput(firstName.trim()), LastName: sanitizeInput(lastName.trim()) }
      });
      if (response.data.length === 0) {
        setSnackbar({ open: true, message: 'No workers found', severity: 'error' });
      }
      const mapped = response.data.map(w => ({
        label: w.NameFull,
        jobTitle: w.JobTitle,
        supervisor: w.SupervisorFullName
      }));
      setResults(mapped);
    } catch (error) {
      setSnackbar({ open: true, message: 'Error fetching workers', severity: 'error' });
      setResults([]);
    } finally {
      setLoading(false);
    }
  };

  const toggleSelect = (workerLabel) => {
    if (selected.includes(workerLabel)) {
      setSelected(selected.filter(x => x !== workerLabel));
    } else {
      setSelected([...selected, workerLabel]);
    }
  };

  const handleDone = () => {
    // When Done is clicked, the new value is committed.
    setOpen(false);
    props.stopEditing(); // This will trigger AG Grid to call getValue()
  };

  return (
    <Dialog open={open} onClose={() => props.stopEditing()} fullWidth maxWidth="sm">
      <DialogTitle>Edit {props.colDef.header}</DialogTitle>
      <DialogContent>
        <TextField
          label="First Name"
          value={firstName}
          onChange={e => setFirstName(e.target.value)}
          fullWidth
          margin="normal"
        />
        <TextField
          label="Last Name"
          value={lastName}
          onChange={e => setLastName(e.target.value)}
          fullWidth
          margin="normal"
        />
        <Button onClick={searchWorkers} variant="contained" disabled={loading} sx={{ mt: 1 }}>
          {loading ? <CircularProgress size={20} /> : "Search"}
        </Button>
        {results.length > 0 && (
          <Box sx={{ mt: 2 }}>
            <List>
              {results.map(worker => {
                const labelId = `checkbox-list-label-${worker.label}`;
                return (
                  <ListItem key={worker.label} button onClick={() => toggleSelect(worker.label)}>
                    <ListItemIcon>
                      <Checkbox checked={selected.includes(worker.label)} />
                    </ListItemIcon>
                    <ListItemText primary={worker.label} secondary={`Job: ${worker.jobTitle} | Supervisor: ${worker.supervisor}`} />
                  </ListItem>
                );
              })}
            </List>
          </Box>
        )}
      </DialogContent>
      <DialogActions>
        <Button onClick={() => props.stopEditing()}>Cancel</Button>
        <Button onClick={handleDone} variant="contained">Done</Button>
      </DialogActions>
      <Snackbar
        open={snackbar.open}
        autoHideDuration={4000}
        onClose={() => setSnackbar({ ...snackbar, open: false })}
      >
        <Alert onClose={() => setSnackbar({ ...snackbar, open: false })} severity={snackbar.severity}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </Dialog>
  );
});
WorkerNamesCellEditor.displayName = 'WorkerNamesCellEditor';

// ----------------------- ProfileTypeRenderer -----------------------
// This custom cell renderer simulates Level 3 by providing a toggle button
// that, when clicked, shows additional information (profile type definitions).
const ProfileTypeRenderer = (props) => {
  const [open, setOpen] = useState(false);
  const definitions = {
    Provider: "Supplies services to other BUs.",
    Consumer: "Receives services from other BUs.",
    Both: "Acts as both Provider and Consumer.",
    Inheritor: "Inherits control from another BU."
  };
  
  return (
    <div>
      <Button size="small" onClick={() => setOpen(!open)}>
        {open ? "Hide Info" : "Show Info"}
      </Button>
      {open && (
        <div style={{ marginTop: 4, backgroundColor: '#f4f4f4', padding: 8, borderRadius: 4 }}>
          <ul style={{ margin: 0, paddingLeft: 16 }}>
            {props.value ? (
              <li><strong>{props.value}:</strong> {definitions[props.value] || "No definition available."}</li>
            ) : (
              <li>No Profile Type selected.</li>
            )}
          </ul>
        </div>
      )}
    </div>
  );
};

// ----------------------- Main Component: CSFScopeAGGrid -----------------------
const CSFScopeAGGrid = () => {
  const [rowData, setRowData] = useState([]);

  // Fetch ScopeData and group by subcategoryId (Level 1: Subcategories)
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get('/api/ScopeData');
        const grouped = {};
        response.data.forEach(item => {
          if (!grouped[item.subcategoryId]) {
            grouped[item.subcategoryId] = {
              subcategoryId: item.subcategoryId,
              subcategoryName: item.subcategoryName,
              subcategoryDescription: item.subcategoryDescription,
              relatedSubcategories: item.relatedCsf1_1Subcategories,
              businessUnits: []
            };
          }
          grouped[item.subcategoryId].businessUnits.push(item);
        });
        setRowData(Object.values(grouped));
      } catch (error) {
        console.error('Error fetching scope data:', error);
      }
    };
    fetchData();
  }, []);

  // Master grid (Level 1) column definitions.
  const masterColumnDefs = useMemo(() => [
    { headerName: "Subcategory", field: "subcategoryName", filter: 'agSetColumnFilter' },
    { headerName: "Description", field: "subcategoryDescription" },
    { headerName: "Related Subcategories", field: "relatedSubcategories" }
  ], []);

  // Detail grid (Level 2) column definitions.
  const detailColumnDefs = useMemo(() => [
    { headerName: "BU", field: "businessUnitAbbr", editable: false },
    { 
      headerName: "BU Owner", 
      field: "businessUnitOwner", 
      editable: true,
      cellEditor: "workerNamesCellEditor"
    },
    { 
      headerName: "Auditor Custodian", 
      field: "auditorSubcatCustodian", 
      editable: true,
      cellEditor: "workerNamesCellEditor"
    },
    { 
      headerName: "In Scope?", 
      field: "auditorIsInScope", 
      editable: true,
      cellEditor: "agSelectCellEditor",
      cellEditorParams: { values: ["Yes", "No"] }
    },
    { headerName: "Justification", field: "auditorJustification", editable: true },
    { 
      headerName: "Maturity Projection", 
      field: "maturityProjection", 
      editable: true,
      cellEditor: "agSelectCellEditor",
      cellEditorParams: { values: ["Increase", "Decrease", "Maintain"] }
    },
    { 
      headerName: "Profile Type", 
      field: "auditorProfileType", 
      editable: true,
      cellEditor: "agSelectCellEditor",
      cellEditorParams: { values: ["Provider", "Consumer", "Both", "Inheritor"] },
      cellRenderer: "profileTypeRenderer"
    },
    { 
      headerName: "Consuming From BU", 
      field: "auditorConsumingFromBusinessUnit", 
      editable: true,
      cellEditor: "agSelectCellEditor",
      cellEditorParams: { values: ["ABC", "UIO", "POA", "SKA-C", "Other"] }
    },
    { headerName: "Department Name", field: "departmentName", editable: true }
  ], []);

  // Framework components (custom cell editor and renderer)
  const frameworkComponents = useMemo(() => ({
    workerNamesCellEditor: WorkerNamesCellEditor,
    profileTypeRenderer: ProfileTypeRenderer
  }), []);

  // Detail cell renderer parameters for master/detail mode.
  const detailCellRendererParams = {
    detailGridOptions: {
      columnDefs: detailColumnDefs,
      defaultColDef: {
        flex: 1,
        resizable: true,
        filter: true,
      },
      frameworkComponents: frameworkComponents,
      pagination: true,
      paginationPageSize: 5,
      onCellValueChanged: (params) => {
        console.log('Detail grid cell value changed', params);
      }
    },
    getDetailRowData: (params) => {
      params.successCallback(params.data.businessUnits);
    }
  };

  return (
    <Box className="ag-theme-alpine" style={{ height: "700px", width: "100%" }}>
      <AgGridReact
        rowData={rowData}
        columnDefs={masterColumnDefs}
        masterDetail={true}
        detailCellRendererParams={detailCellRendererParams}
        frameworkComponents={frameworkComponents}
        pagination={true}
        paginationPageSize={10}
        onGridReady={params => params.api.sizeColumnsToFit()}
      />
    </Box>
  );
};

export default CSFScopeAGGrid;
