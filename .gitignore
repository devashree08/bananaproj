import React, { useEffect, useState, useMemo } from "react";
import { MaterialReactTable } from "material-react-table";
import { MenuItem, TextField, Autocomplete, Box, Typography } from "@mui/material";
import axios from "axios";

// Options for Dropdowns
const ProfileTypeOptions = ["Provider", "Consumer", "Both", "Inheritor"];
const BusinessUnitOptions = ["ABC", "UIO", "POA", "SKA-C"];

// Fetch worker names dynamically from API
const fetchWorkerNames = async (inputValue) => {
  try {
    const response = await axios.get(`/api/GetWorkerName?search=${inputValue}`);
    return response.data || [];
  } catch (error) {
    console.error("Error fetching worker names:", error);
    return [];
  }
};

const CSFScopeTable = () => {
  const [tableData, setTableData] = useState([]);

  // Fetch Data on Component Mount
  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get("/api/ScopeData");
        // Group data by subcategory
        const groupedData = Object.values(
          response.data.reduce((acc, item) => {
            if (!acc[item.subcategoryId]) {
              acc[item.subcategoryId] = {
                subcategoryId: item.subcategoryId,
                subcategoryName: item.subcategoryName,
                subcategoryDescription: item.subcategoryDescription,
                relatedSubcategories: item.relatedCsf1_1Subcategories,
                businessUnits: [],
              };
            }
            acc[item.subcategoryId].businessUnits.push(item);
            return acc;
          }, {})
        );
        setTableData(groupedData);
      } catch (error) {
        console.error("Error fetching scope data:", error);
      }
    };
    fetchData();
  }, []);

  // Handle Row Save
  const handleSaveRow = ({ row, values }) => {
    const updatedData = [...tableData];
    const subcategory = updatedData.find((sub) => sub.subcategoryId === row.original.subcategoryId);
    if (subcategory) {
      const buIndex = subcategory.businessUnits.findIndex((bu) => bu.businessUnitAbbr === row.original.businessUnitAbbr);
      if (buIndex !== -1) {
        subcategory.businessUnits[buIndex] = values;
      }
    }
    setTableData(updatedData);
  };

  // **Layer 1: Subcategory Level Columns**
  const SubcategoryColumns = useMemo(
    () => [
      {
        accessorKey: "subcategoryName",
        header: "Subcategory Name",
      },
      {
        accessorKey: "subcategoryDescription",
        header: "Subcategory Description",
      },
      {
        accessorKey: "relatedSubcategories",
        header: "Related Subcategories",
        Cell: ({ cell }) => cell.getValue() || "N/A",
      },
    ],
    []
  );

  // **Layer 2: Business Unit Level (Editable Fields)**
  const BusinessUnitColumns = useMemo(
    () => [
      {
        accessorKey: "businessUnitAbbr",
        header: "Business Unit",
        enableEditing: false, // Make it read-only
      },
      {
        accessorKey: "businessUnitOwner",
        header: "Business Unit Owner",
        Cell: ({ cell }) => (cell.getValue() ? cell.getValue().split(", ").join(", ") : "N/A"),
        Edit: ({ row, column, table }) => (
          <Autocomplete
            multiple
            options={[]} // Will be updated dynamically
            defaultValue={row.original[column.id] ? row.original[column.id].split(", ") : []}
            onInputChange={async (event, newValue) => {
              if (newValue) {
                const workerNames = await fetchWorkerNames(newValue);
                table.options.mutateRowData(row.id, {
                  [column.id]: workerNames.join(", "),
                });
              }
            }}
            renderInput={(params) => <TextField {...params} label="Search Owners" />}
          />
        ),
      },
      {
        accessorKey: "auditorSubcatCustodian",
        header: "Auditor Subcategory Custodian",
        Cell: ({ cell }) => (cell.getValue() ? cell.getValue().split(", ").join(", ") : "N/A"),
        Edit: ({ row, column, table }) => (
          <Autocomplete
            multiple
            options={[]} // Will be updated dynamically
            defaultValue={row.original[column.id] ? row.original[column.id].split(", ") : []}
            onInputChange={async (event, newValue) => {
              if (newValue) {
                const workerNames = await fetchWorkerNames(newValue);
                table.options.mutateRowData(row.id, {
                  [column.id]: workerNames.join(", "),
                });
              }
            }}
            renderInput={(params) => <TextField {...params} label="Search Custodians" />}
          />
        ),
      },
      {
        accessorKey: "auditorIsInScope",
        header: "Auditor Is In Scope",
        Edit: ({ cell, table }) => (
          <TextField
            select
            defaultValue={cell.getValue() || ""}
            onChange={(event) => table.options.mutateRowData(cell.row.id, { auditorIsInScope: event.target.value })}
          >
            <MenuItem value="Yes">Yes</MenuItem>
            <MenuItem value="No">No</MenuItem>
          </TextField>
        ),
      },
      {
        accessorKey: "auditorJustification",
        header: "Auditor Justification",
        Edit: ({ cell, table }) => (
          <TextField
            defaultValue={cell.getValue() || ""}
            onChange={(event) => table.options.mutateRowData(cell.row.id, { auditorJustification: event.target.value })}
            disabled={cell.row.original.auditorIsInScope !== "No"}
          />
        ),
      },
    ],
    []
  );

  // **Layer 3: Profile Type Info Panel**
  const renderInfoPanel = () => (
    <Box p={2}>
      <Typography variant="h6">Profile Type Definitions:</Typography>
      <ul>
        <li><strong>Provider</strong> - Supplies services to other BUs</li>
        <li><strong>Consumer</strong> - Receives services from other BUs</li>
        <li><strong>Both</strong> - Acts as both Provider & Consumer</li>
        <li><strong>Inheritor</strong> - Inherits control from another BU</li>
      </ul>
    </Box>
  );

  // Render Nested Business Unit Table (Expands on Subcategory Level)
  const renderSubRow = ({ row }) => (
    <MaterialReactTable
      columns={BusinessUnitColumns}
      data={row.original.businessUnits}
      enableEditing
      editingMode="cell"
      onEditingRowSave={handleSaveRow}
      renderDetailPanel={renderInfoPanel} // Layer 3: Info Panel
    />
  );

  return (
    <MaterialReactTable
      columns={SubcategoryColumns}
      data={tableData}
      enableExpanding
      renderDetailPanel={renderSubRow} // Expands to Layer 2 (BU Level)
    />
  );
};

export default CSFScopeTable;
